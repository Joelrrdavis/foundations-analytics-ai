<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.55">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>AI Systems: Data, Models, and Logic – Foundations of Analytics &amp; AI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="access.theme.scss">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Foundations of Analytics &amp; AI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-textbook" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Textbook</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-textbook">    
        <li>
    <a class="dropdown-item" href="../textbook_src/ch1_foundations_analytics_ai_split.html">
 <span class="dropdown-text">Ch 1. What Is Analytics &amp; AI?</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch2_ai_systems_data_models_logic.html">
 <span class="dropdown-text">Ch 2. AI Systems: Data, Models, Logic</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch3_data_pipelines_decision_frameworks.html">
 <span class="dropdown-text">Ch 3. Data Pipelines &amp; Decision Frameworks</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch4_terminal_paths_envs.html">
 <span class="dropdown-text">Ch 4. Python Execution Foundations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch5_python_foundations_data_control_functions.html">
 <span class="dropdown-text">Ch 5. Python Basics: Data, Control, Functions</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch6_working_with_tabular_data_pandas.html">
 <span class="dropdown-text">Ch 6. Working with Tabular Data in Pandas</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch7_json_apis_data_access.html">
 <span class="dropdown-text">Ch 7. JSON and APIs for Data Access</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch8_simulation_synthetic_data.html">
 <span class="dropdown-text">Ch 8. Simulation and Synthetic Data</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../textbook_src/ch9_visualization_from_data_to_insight.html">
 <span class="dropdown-text">Ch 9. Visualization: From Data to Insight</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-guides" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Guides</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-guides">    
        <li>
    <a class="dropdown-item" href="../guides/terminal_powershell_basics.html">
 <span class="dropdown-text">Terminal and PowerShell Basics</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/setup_python_uv_vscode.html">
 <span class="dropdown-text">Install Python, uv, VS Code</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/using_colab.html">
 <span class="dropdown-text">Using Colab</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../guides/vscode_update_stability.html">
 <span class="dropdown-text">Locking VS Code Updates (Optional)</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#data-models-and-logic-core-components-of-ai-systems" id="toc-data-models-and-logic-core-components-of-ai-systems" class="nav-link active" data-scroll-target="#data-models-and-logic-core-components-of-ai-systems">Data, Models, and Logic: Core Components of AI Systems</a>
  <ul class="collapse">
  <li><a href="#data" id="toc-data" class="nav-link" data-scroll-target="#data">Data</a></li>
  <li><a href="#models" id="toc-models" class="nav-link" data-scroll-target="#models">Models</a></li>
  <li><a href="#logic" id="toc-logic" class="nav-link" data-scroll-target="#logic">Logic</a></li>
  <li><a href="#where-systems-fail-data-model-logic-layers" id="toc-where-systems-fail-data-model-logic-layers" class="nav-link" data-scroll-target="#where-systems-fail-data-model-logic-layers">Where Systems Fail (Data, Model, Logic Layers)</a></li>
  </ul></li>
  <li><a href="#ai-paradigms-overview" id="toc-ai-paradigms-overview" class="nav-link" data-scroll-target="#ai-paradigms-overview">AI Paradigms Overview</a>
  <ul class="collapse">
  <li><a href="#symbolic-ai" id="toc-symbolic-ai" class="nav-link" data-scroll-target="#symbolic-ai">Symbolic AI</a></li>
  <li><a href="#statistical-and-machine-learning" id="toc-statistical-and-machine-learning" class="nav-link" data-scroll-target="#statistical-and-machine-learning">Statistical and Machine Learning</a></li>
  <li><a href="#neural-and-deep-learning" id="toc-neural-and-deep-learning" class="nav-link" data-scroll-target="#neural-and-deep-learning">Neural and Deep Learning</a></li>
  <li><a href="#hybrid-systems-in-practice" id="toc-hybrid-systems-in-practice" class="nav-link" data-scroll-target="#hybrid-systems-in-practice">Hybrid Systems in Practice</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">AI Systems: Data, Models, and Logic</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="data-models-and-logic-core-components-of-ai-systems" class="level2">
<h2 class="anchored" data-anchor-id="data-models-and-logic-core-components-of-ai-systems">Data, Models, and Logic: Core Components of AI Systems</h2>
<figure class="figure">
<img src="../assets/images/nested_ai.svg" class="figure-img"> alt=“Core AI system diagram showing a left-to-right flow: Data feeds into Model, Model feeds into Logic, and Logic triggers Action. Arrows indicate sequential flow from inputs to decisions.”&gt;
<figcaption>
An AI system is best understood as the interaction of data, a model, and decision logic—rather than as a model alone.
</figcaption>
</figure>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>Data forms the foundation of all analytics and AI systems. Regardless of how sophisticated a model or decision framework may be, the behavior of the system is entirely shaped by the data it has availble. Understanding what data represents, how it is generated, and how it enters a system is a critical step on the way to understanding how AI systems operate.</p>
<p>Very broadly defined, data is <strong>recorded observations about the world</strong>. These observations take many forms: transaction records, sensor readings, text documents, images, user interactions, or system logs. These data sources might all differ in structure and complexity, but they all capture <strong>past events</strong> or states that can be analyzed, modeled, and in some cases acted upon.</p>
<p>Data serves two very critical functions within AI systems. First, it is used to <strong>train models</strong>. Historical data provides the needed examples from which AI models learn patterns, relationships, or representations. The coverage and quality of this data directly influence what a model can learn and how well it generalizes <em>beyond</em> its training examples. Second, data is used during <strong>system operation</strong>, when new observations are provided as input to a trained model in order to generate predictions, classifications, or scores. The key thing to remember here is that errors, shifts, or inconsistencies in <em>either</em> training data <em>or</em> operational data can degrade system performance.</p>
<p>For the most part, data is not a complete or neutral representation of reality. Data always reflects the processes through which it was collected. These include factors such as organizational priorities, technical constraints, and human choices. Some phenomena are simply easier to observe and record than others, some groups or behaviors are overepresented, and some variables serve only as indirect proxies for what is actually of interest. As a result, data commonly contains noise, omissions, and systematic issues that need to be addressed.</p>
<p>From a systems perspective, data does not simply exist, ready to be used by whatever model is in place; it is <strong>acquired and prepared</strong>, in a process that is often referred to or thought of as a pipelines. These pipelines involve decisions about what to collect, how frequently to collect it, how it is stored, and how it is cleaned or transformed before use. Choices made at this stage, such as how missing values are handled or how categories are encoded, can have consequences that propagate throughout the system. Often in surprising ways.</p>
<p>Effective analysis of AI systems begins with careful attention to the data being collected. Asking where data comes from, what it represents, and what it leaves out is often the most, and sometimes the only, reliable way to understand system behavior, anticipate limitations, and diagnose failures.</p>
<p>A defining challenge for artificial intelligence systems is that they must operate under uncertainty. Data is often incomplete, noisy, delayed, or sometimes just plain wrong. Models can only approximate real-world processes. AI models don’t try to eliminating uncertainty, but these systems are designed to manage and act despite it, using probabilistic reasoning, learned patterns, and decision logic to function in the imperfect environments they are placed in.</p>
</section>
<section id="models" class="level3">
<h3 class="anchored" data-anchor-id="models">Models</h3>
<p>A <strong>model</strong> is a formal representation of a relationship between inputs and outputs. In analytics and AI systems, models are used to map the observed data to predictions, classifications, scores, or other quantities that support decision-making. While models can take many forms—from simple equations to complex neural networks—their role within a system is conceptually consistent: they provide a structured way to generalize from past observations to new situations.</p>
<p>Models differ from raw data in an important way. Data records what has already happened. The key word to remember there is “already”. All data is from the past. we can’t collect data on the future. Models on the other hand encode assumptions about <strong>how the world works</strong>. The assumptions the model makes might explicit. Very clear assumptions that are easily interpretable, as in a linear equation that specifies how inputs specifically combine to produce some output. Or the model might be more implicit, as in a deep learning model that learns internal representations through training on large datasets . In both cases, the model embodies a hypothesis about underlying patterns found in the data.</p>
<p>Models are created through a <strong>training process</strong>. Historical data is used to adjust a model’s parameters so that its outputs align as closely as possible with observed outcomes. This process allows the model to capture regularities in the data, but it also ties the model’s behavior to the quality and scope of the data it was trained on. A model cannot reliably learn patterns that are absent, rare, or systematically distorted in the training data.</p>
<p>Once trained, a model is given new outputs, and used the representation that is learned in training, to generate an output. These outputs are often <strong>probabilistic</strong> rather than deterministic, the model can’t “know” that the process it followed to map the input data and adjust it’s parameters is accurate or without loss. Instead of producing a single “correct” answer, a model may estimate the likelihood of different outcomes or assign scores that reflect a relative confidence in a range of outputs. This probabilistic nature is a strength as it allows models to operate under a high level of uncertainty.</p>
<p>Talking about models this way is perhaps a little dangerous. Models are not inherently intelligent or autonomous. They do not understand context, intent, or consequences in a human sense. Instead, they apply their learned patterns mechanically, based on the structure learned in training. This allows them to perform exceptionally well within familiar constraints, boundaries and conditoins, while while behaving unpredictably when those conditions change.</p>
<p>Models can recognize patterns, make estimates, and scale decisions, but they do so within the boundaries defined by the data available, training procedures, and design choices of the models architect.</p>
</section>
<section id="logic" class="level3">
<h3 class="anchored" data-anchor-id="logic">Logic</h3>
<p>Data, and the models that result with training are often the most visible, and perhaps “coolest” components of AI systems. But <strong>logic</strong> is what ultimately connects model outputs to real-world actions. Logic defines how predictions, scores, or classifications are interpreted and how they are translated into actions.</p>
<p>Logic is the <strong>rules, thresholds, constraints, and objectives</strong> that govern a systems behavior. These elements specify what should happen when a model produces a given output. In a system designed to detect credit card fraud, a model may provide a probability score that fraud has occured. This score might then be compared against some threshold, the level at which the busines would like to take action on the prediction, and an alert triggered. These thresholds are not inherent to the model; the model jsut outputs the prediction. These thresholds are design choices that reflect priorities, trade-offs, and risk tolerance.</p>
<p>Logic also encodes <strong>business or organizational constraints</strong>. All businessnes and organizations face at least some constraints, things like resource limitations, regulatory requirements, fairness considerations, or cost structures. A model might identify many high-risk cases, but logic determines how many can realistically be acted upon, which cases are prioritized, and which actions are permissible. As a result, logic often mediates between what a model suggests and what an organization can or should do.</p>
<p>Logic can be implemented in various ways. In some systems, it takes the form of explicit rules written by humans, “when we see x we do y”. In others, it can be nuanced, the logic embedded within optimization routines, data collection policies, or decision frameworks. Even when decisions by a system appear automated, they are often controlled by the logic layered on through past human judgments about acceptable or optimal outcomes.</p>
<p><strong>Models produce outputs, but logic determines actions</strong>.</p>
</section>
<section id="where-systems-fail-data-model-logic-layers" class="level3">
<h3 class="anchored" data-anchor-id="where-systems-fail-data-model-logic-layers">Where Systems Fail (Data, Model, Logic Layers)</h3>
<p>Failures in analytics and AI systems rarely originate from a single cause. Instead, they tend to emerge from breakdowns at one or more layers of the the system: <strong>data</strong>, <strong>models</strong>, or <strong>logic</strong>. Understanding these layers, and the interactions between them, provide a structured way to diagnose system results and understan why a system produces s sub optimal outcome.</p>
<p>Failures at the <strong>data layer</strong> occur when the information the system is training on is incomplete, too noisy, or no longer representative of the process you want to model. These issues may take the form of missing values, measurement errors, outdated records, or shifts in underlying patterns over time. Because models learn from historical data, weaknesses at this layer often propagate forward, limiting what the system can reasonably achieve regardless of model sophistication.</p>
<p>Failures at the <strong>model layer</strong> arise when the model itself is poorly matched to the problme, task or data available. This may involve using overly simplistic models that fail to capture comples but important relationships. Conservesly this is also sometimes the use of overly complex models that overfit historical patterns. Even well-designed models can fail when deployed in contexts that differ meaningfully from those seen during training.</p>
<p>Failures at the <strong>logic layer</strong> occur when model outputs are translated into decisions inappropriately. This is often simply poorly chosen or arbitrary thresholds, rigid rules that do not adapt to changing conditions, or decision criteria that prioritize the wrong objectives. In these cases, a model may be producing reasonable outputs, but the surrounding logic causes undesirable actions or missed opportunities.</p>
<p>These layers are closely intertwined. High data quality and a strong model can’t save a system with seriously flawed logic. Likewise, careful logic cannot compensate for fundamentally uninformative or skewed data.</p>
<p>Viewing failures through this layered lens encourages more precise diagnosis and more effective intervention. Rather than asking whether an AI system “works” or “does not work,” it becomes possible to ask <em>where</em> it is breaking down and <em>why</em>. This perspective supports more thoughtful system evaluation and more responsible use of analytics and AI in decision-making contexts.</p>
</section>
</section>
<section id="ai-paradigms-overview" class="level2">
<h2 class="anchored" data-anchor-id="ai-paradigms-overview">AI Paradigms Overview</h2>
<figure class="figure">
<img src="../assets/images/1_qmb_nested_ai.svg" alt="Conceptual diagram showing AI as the broad area, with machine learning as a subset and deep learning as a further subset." class="figure-img">
<figcaption>
A useful shorthand: AI includes many approaches, with machine learning and deep learning representing increasingly specialized subsets.
</figcaption>
</figure>
<section id="symbolic-ai" class="level3">
<h3 class="anchored" data-anchor-id="symbolic-ai">Symbolic AI</h3>
<p>Symbolic systems rely on <strong>explicit representations of knowledge</strong> and <strong>rule-based reasoning</strong> to perform tasks. Contrast that with the types of systems we have been discussing so far, that use pattern recognition from data. These systems operate by manipulating inputs (words, categories, etc) according to predefined rules.</p>
<p>The main idea in this approach is that intelligent behavior can be produced by encoding expert knowledge directly, as a series of rules and decision points, into a system. This often takes the form of <em>if–then</em> rules. For example, a symbolic system might contain rules such as: <em>if a customer is late on payment and has missed multiple deadlines, then flag the account for review</em>. Each rule reflects a human and/or expert judgment that has been translated into formal logic.</p>
<p>Symbolic AI systems tend to be <strong>transparent and interpretable</strong>. Because their reasoning process is explicitly defined, it is usually possible to trace back to how particular outcome was reached by the system. This makes these symbolic approaches attractive, and sometimes even required, in domains where explanations, compliance, or auditability are critical. They perform best in environments where the rules are stable and the the problem space and scope is well understood, and rarely changes.</p>
<p>There are some obvious limitations. Writing and maintaining rules is labor-intensive, complex, and such systems almost always struggle to scale as complexity increases. They also perform poorly in settings characterized by ambiguity, noise, or high variability (change).</p>
<p>While symbolic AI is no longer the dominant paradigm in many areas, it remains an important conceptual foundation. Many modern systems still rely on symbolic components for constraints, validation, and control, even when learning-based models are used elsewhere. Understanding symbolic AI helps clarify both the strengths of explicit reasoning and the challenges that motivated the development of data-driven approaches addressed in the next sections.</p>
</section>
<section id="statistical-and-machine-learning" class="level3">
<h3 class="anchored" data-anchor-id="statistical-and-machine-learning">Statistical and Machine Learning</h3>
<p>Statistical and machine learning approaches to AI differ from symbolic systems in a fundamental way: rather than relying on explicitly programmed rules, they <strong>learn patterns from data</strong>. These approaches use historical observations to infer relationships between inputs and outputs, allowing systems to generalize to new, unseen cases without being told exactly how to respond in every situation.</p>
<p>At the heart of machine learning is the idea that regularities in data can be captured through mathematical models whose parameters are estimated from examples. During training, a model is exposed to data and adjusted so that its predictions align with observed outcomes as closely as possible. This process allows the system to adapt to complex patterns that would be difficult to specify manually using rules alone.</p>
<p>Machine learning methods are often categorized based on the type of feedback available during training. In <strong>supervised learning</strong>, the model is trained using labeled examples, where the correct output is known in advance. Common applications include classification and regression tasks, such as predicting customer churn or estimating demand. In <strong>unsupervised learning</strong>, the model works with unlabeled data to identify structure, such as clusters or latent patterns, without predefined outcomes. Both approaches are widely used in analytics and AI systems.</p>
<p>Compared to symbolic AI, statistical and machine learning systems are generally more flexible and scalable. They perform well in environments with large volumes of data and can adapt to subtle patterns and correlations. However, this flexibility comes with trade-offs. Learned models may be less transparent, and their behavior can be sensitive to the data used for training. As a result, understanding and validating model performance often requires careful evaluation rather than direct inspection of rules.</p>
<p>Importantly, statistical and machine learning approaches do not eliminate the need for human judgment. Choices about which data to use, which features to include, how to evaluate performance, and how to deploy model outputs remain human decisions. Machine learning shifts the burden of specification from rule-writing to <strong>data curation and model design</strong>, redefining where expertise is applied within AI systems.</p>
<p>This paradigm has become central to modern analytics and AI, forming the basis for many applications encountered in practice. It also provides the foundation for more advanced approaches, such as neural and deep learning, discussed next.</p>
</section>
<section id="neural-and-deep-learning" class="level3">
<h3 class="anchored" data-anchor-id="neural-and-deep-learning">Neural and Deep Learning</h3>
<p>Neural and deep learning approaches extend statistical machine learning by focusing on <strong>learning representations</strong> directly from data. Rather than relying on hand-crafted features or simple functional forms, these models use layered computational structures—commonly referred to as <em>neural networks</em>—to transform raw inputs into increasingly abstract representations.</p>
<p>The key idea behind neural networks is inspired by, but not equivalent to, biological neurons. A neural network is composed of interconnected units that apply weighted combinations of inputs followed by nonlinear transformations. By stacking many such layers, deep learning models can capture complex patterns in high-dimensional data. This layered structure allows them to excel in tasks such as image recognition, speech processing, and natural language understanding, where relationships are difficult to specify explicitly.</p>
<p>One defining characteristic of deep learning is its ability to operate on <strong>unstructured or semi-structured data</strong>, including images, audio, and text. In these domains, traditional statistical models often require extensive feature engineering. Deep learning models, by contrast, can learn relevant representations automatically from large volumes of data, reducing the need for manual specification of features.</p>
<p>This capability comes with important trade-offs. Neural and deep learning models are typically <strong>data-intensive and computationally demanding</strong>. Training them often requires large datasets, specialized hardware, and careful tuning. They also tend to be less interpretable than simpler models, making it more difficult to explain why a particular output was produced. As a result, deployment of deep learning systems often involves additional monitoring, validation, and governance mechanisms.</p>
<p>Despite these challenges, neural and deep learning approaches have reshaped the AI landscape. Many contemporary systems—including speech recognition, computer vision applications, and large language models—are built on deep learning architectures. Understanding this paradigm helps clarify why modern AI systems can handle tasks that were previously infeasible, as well as why concerns about transparency, robustness, and control remain central to their use.</p>
<p>Neural and deep learning approaches are rarely used in isolation. In practice, they are often combined with statistical methods and symbolic logic to form integrated systems, a topic addressed next.</p>
</section>
<section id="hybrid-systems-in-practice" class="level3">
<h3 class="anchored" data-anchor-id="hybrid-systems-in-practice">Hybrid Systems in Practice</h3>
<figure class="figure">
<img src="../assets/images/1_hybrid_paradigm.svg" alt="Hybrid AI paradigm diagram showing learned components, rule-based components, and human oversight combining into a decision layer." class="figure-img">
<figcaption>
Most real-world AI systems blend machine learning, rules, and human oversight rather than relying on a single paradigm.
</figcaption>
</figure>
<p>In real-world applications, AI systems rarely rely on a single paradigm. Instead, they are typically <strong>hybrid systems</strong> that combine symbolic reasoning, statistical or machine learning models, and neural or deep learning components. Each paradigm contributes different strengths, and hybrid designs allow systems to balance performance, interpretability, and control.</p>
<p>A common pattern in hybrid systems is the use of <strong>learning-based models for perception and prediction</strong>, paired with <strong>symbolic or rule-based logic for decision-making and constraints</strong>. For example, a deep learning model may be used to recognize objects in an image or extract meaning from text, while a rule-based layer determines whether the output meets regulatory requirements or triggers a specific action. In this structure, learning handles complexity and variability, while symbolic logic enforces consistency and accountability.</p>
<p>Hybrid systems also help address practical limitations of individual approaches. Machine learning models can adapt to data and capture subtle patterns, but they may behave unpredictably outside familiar conditions. Symbolic logic can impose guardrails, prevent certain actions, or require human review under specified circumstances. Statistical models can provide calibrated probabilities that support decision thresholds and prioritization. Together, these components form systems that are more robust than any single approach alone.</p>
<p>Many modern AI applications illustrate this hybrid structure. Recommendation systems often combine learned user preference models with business rules and inventory constraints. Fraud detection systems use predictive models to score transactions and rule-based logic to manage alerts and workflows. Large language model applications frequently pair neural models with retrieval systems, validation rules, and structured decision logic to ensure usable and reliable outputs.</p>
<p>Understanding AI systems as hybrids reinforces an important perspective: intelligence in practice is <strong>distributed across system components</strong>, not concentrated in a single model. Performance, reliability, and responsibility emerge from how data, models, and logic are assembled and governed. This systems-level view provides a foundation for analyzing and designing AI applications that operate effectively within real organizational and societal constraints.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>